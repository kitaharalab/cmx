package jp.crestmuse.cmx.misc;
import java.util.*;

public class BinaryTree<E> {

    public static enum NodeAdditionPolicy {APPEND_TO_LEAF, SORT};
    public static enum PathPriority {LEFT, RIGHT};

    private Node head;
    private Node current;
    private NodeAdditionPolicy additionPolicyL;
    private NodeAdditionPolicy additionPolicyR;
    private PathPriority prioredPath;
    private Comparator<E> cmpL, cmpR;

    public BinaryTree(NodeAdditionPolicy pL, 
			 NodeAdditionPolicy pR, 
			 PathPriority pp) {
	additionPolicyL = pL;
	additionPolicyR = pR;
	prioredPath = pp;
	head = new Node();
        current = head;
    }

    private BinaryTree(Node head, 
                       NodeAdditionPolicy pL, 
                       NodeAdditionPolicy pR, 
                       PathPriority pp) {
        additionPolicyL = pL;
        additionPolicyR = pR;
        prioredPath = pp;
        this.head = head;
        current = head;
    }		       

    public final void setComparatorL(Comparator<E> c) {
	cmpL = c;
    }

    public final void setComparatorR(Comparator<E> c) {
	cmpR = c;
    }

    public void add(E e, String label) {
        if (prioredPath == PathPriority.LEFT)
	    current = current.insertToLeftPath(e, label);
	else if (prioredPath == PathPriority.RIGHT)
	    current = current.insertToRightPath(e, label);
	else
	    throw new IllegalArgumentException
	        ("Illegal PathPriority: " + prioredPath);
    }

    public final BinaryTree<E> getSubTree() {
        return new BinaryTree<E>(current, additionPolicyL, 
                                 additionPolicyR, prioredPath);
    }

    public final void appendTreeToLeftChild(BinaryTree<E> t, String label) {
        if (current.childL == null) {
	    current.setChildL(t.head, label);
//            current.childL = t.head;
//	    t.head.parent = current.childL;
//	    current.labelL = label;
        } else {
            Node emptynode = new Node();
	    emptynode.setChildL(current.childL, current.labelL);
	    emptynode.setChildR(current.childR, current.labelR);
	    current.setChildR(emptynode, "");
	    current.setChildL(t.head, label);
        }
    }

    public final void appendTreeToRightChild(BinaryTree<E> t, String label) {
        if (current.childR == null) {
	    current.setChildR(t.head, label);
        } else {
            Node emptynode = new Node();
            emptynode.setChildL(current.childL, current.labelL);
	    emptynode.setChildR(current.childR, current.labelR);
	    current.setChildL(emptynode, "");
	    current.setChildR(t.head, label);
	}
    }

    public final E getCurrent() {
        return current.entry;
    }

    public final E getChildL() {
        return current.childL.entry;
    }

    public final E getChildR() {
        return current.childR.entry;
    }

    public final E getParent() {
        return current.parent.entry;
    }

    public String toString() {
        return head.toString();
    }


    private final class Node {
	private E entry = null;
	private Node childL = null, childR = null;
	private Node parent = null;
	private String labelL = "", labelR = "";

	private Node() {
	    super();
	}

	private Node(E e) {
	    super();
	    entry = e;
	}

	private void setChildL(Node n, String label) {
	    childL = n;
            n.parent = this;
            labelL = label;
        }

	private void setChildR(Node n, String label) {
            childR = n;
            n.parent = this;
	    labelR = label;
        }

	private Node insertToChildL(E e, String label) {
	    Node newnode = new Node(e);
	    if (childL != null) {
	        newnode.setChildL(childL, labelL);
//		newnode.childL = this.childL;
//		this.childL.parent = newnode;
//		newnode.labelL = this.labelL;
	    }
	    setChildL(newnode, label);
//	    this.childL = newnode;
//	    newnode.parent = this;
//	    this.labelL = label;
	    return newnode;
	}

	private Node insertToChildR(E e, String label) {
	    Node newnode = new Node(e);
	    if (childR != null) {
	        newnode.setChildR(childR, labelR);
//		newnode.childR = this.childR;
//		this.childR.parent = newnode;
//		newnode.labelR = this.labelR;
	    }
	    setChildR(newnode, label);
//	    this.childR = newnode;
//	    newnode.parent = this;
//	    this.labelR = label;
	    return newnode;
	}

	private Node appendToLeftLeaf(E e, String label) {
	    Node newnode = new Node(e);
	    if (childL != null) {
		return childL.appendToLeftLeaf(e, label);
	    } else {
	        setChildL(newnode, label);
//		childL = newnode;
//		newnode.parent = this;
//		labelL = label;
		return newnode;
	    }
	}

	private Node appendToRightLeaf(E e, String label) {
	    Node newnode = new Node(e);
	    if (childR != null) {
		return childR.appendToRightLeaf(e, label);
	    } else {
	        setChildR(newnode, label);
//		childR = newnode;
//		newnode.parent = this;
//		labelR = label;
		return newnode;
	    }
	}

	private int compareL(E e) {
	    if (entry == null)
	        return 1;
            else
                return cmpL.compare(e, entry);
        }

	private int compareR(E e) {
	    if (entry == null)
	        return 1;
            else
                return cmpR.compare(e, entry);
	}

	private int compareToChildL(E e) {
	    if (childL == null)
                return -1;
            else if (childL.entry == null)
                return 1;
            else
                return cmpL.compare(e, childL.entry);
        }

        private int compareToChildR(E e) {
            if (childR == null)
               return -1;
            else if (childR.entry == null)
               return 1;
            else 
               return cmpR.compare(e, childR.entry);
        }

	private Node insertToSortedLeftPath(E e, String label) {
	    if (compareL(e) < 0)
	        return parent.insertToSortedLeftPath(e, label);
            else if (compareToChildL(e) >= 0)
                if (childL == null)
                    return appendToLeftLeaf(e, label);
		else
		    return childL.insertToSortedLeftPath(e, label);
            else if (compareL(e) == 0)
                return insertToRightPath(e, label);
            else 
	        return insertToChildL(e, label);
        }

	private Node insertToSortedRightPath(E e, String label) {
	    if (compareR(e) < 0)
	        return parent.insertToSortedLeftPath(e, label);
	    else if (compareToChildR(e) >= 0)
                if (childR == null)
		    return appendToRightLeaf(e, label);
		else
		    return childR.insertToSortedRightPath(e, label);
            else if (compareR(e) == 0)
                return insertToLeftPath(e, label);
            else
                return insertToChildR(e, label);
        }


	private Node insertToLeftPath(E e, String label) {
	    if (additionPolicyL == NodeAdditionPolicy.APPEND_TO_LEAF)
		return appendToLeftLeaf(e, label);
	    else if (additionPolicyL == NodeAdditionPolicy.SORT)
		return insertToSortedLeftPath(e, label);
	    else
		throw new IllegalArgumentException("Invalid: " + 
						   additionPolicyL);
	}

	private Node insertToRightPath(E e, String label) {
	    if (additionPolicyR == NodeAdditionPolicy.APPEND_TO_LEAF)
		return appendToRightLeaf(e, label);
	    else if (additionPolicyR == NodeAdditionPolicy.SORT)
		return insertToSortedRightPath(e, label);
	    else
		throw new IllegalArgumentException("Invalid: " + 
						   additionPolicyR);
	}


	public String toString() {
	    return "(" + entry + " " + childL + " " + childR + ")";
        }

    }

    public static void main(String[] args) {
	BinaryTree<Double> t = 
	    new BinaryTree<Double>(NodeAdditionPolicy.SORT, 
				    NodeAdditionPolicy.APPEND_TO_LEAF,
				    PathPriority.RIGHT);
	t.setComparatorL(new Comparator<Double>() {
	    public int compare(Double i, Double j) {
		   return (int)i.doubleValue() - (int)j.doubleValue();
            }
        });
	t.head.appendToLeftLeaf(1.0, "");
	t.head.childL.insertToSortedLeftPath(-1.0, "");
	t.head.insertToSortedLeftPath(2.0, "");
	t.head.insertToSortedLeftPath(2.4, "");
	t.head.insertToSortedLeftPath(2.7, "");
	t.head.insertToSortedLeftPath(1.0, "");
	t.head.insertToSortedLeftPath(-20.0, "");
//        System.out.print(t.head.childL.compareL(-1));
        System.out.println(t.head);
/*	t.head.insertToLeftPath(1, "");
	t.head.insertToLeftPath(2, "");
	t.head.insertToLeftPath(3, "");
	t.head.insertToLeftPath(2, "");
  */
  }
}